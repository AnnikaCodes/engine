#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');

const {execFileSync} = require('child_process');
const {Dex} = require('@pkmn/dex');
const {Generations} = require('@pkmn/data');

const pret = 'https://raw.githubusercontent.com/pret/pokered/master/';
const out = path.resolve(__dirname, '../src/data');

// TODO: replace with general Zig formatting step
const zigfmt = f => execFileSync('zig', ['fmt', f], {stdio: 'inherit'});
const toEnum = s => s.replace(/[^A-Za-z0-9]+/g, '');

const UPDATE = process.argv.length > 2;
const PREAMBLE = '//! Code generated by `tools/generate` - manual edits will be overwritten.\n';

async function moveIDs(gen) {
  const txt = path.resolve(__dirname, 'data/moves.txt');

  if (UPDATE) {
    try {
      const moves = [];
      const asm = await (await fetch(`${pret}/data/moves/moves.asm`)).text();
      for (const line of asm.split('\n')) {
        const match = /move (\w+),/.exec(line);
        if (match) {
          const token = match[1] === 'PSYCHIC_M' ? 'PSYCHIC' : match[1];
          moves.push(toEnum(gen.moves.get(token).name));
        }
      }
      fs.writeFileSync(txt, moves.join('\n') + '\n');
      return moves;
    } catch (err) {
      console.error(err);
    }
  }

  const moves = [];
  for (const line of fs.readFileSync(txt, 'utf8').split('\n')) {
    if (!line) continue;
    moves.push(line.trim());
  }
  return moves;
}

async function speciesIDs(gen) {
  const txt = path.resolve(__dirname, 'data/species.txt');

  if (UPDATE) {
    try {
      const species = [];
      const asm = await (await fetch(`${pret}/constants/pokedex_constants.asm`)).text();
      for (const line of asm.split('\n')) {
        const match = /const DEX_(\w+)/.exec(line);
        if (match) species.push(toEnum(gen.species.get(match[1]).name));
      }
      fs.writeFileSync(txt, species.join('\n') + '\n');
      return species;
    } catch (err) {
      console.error(err);
    }
  }

  const species = [];
  for (const line of fs.readFileSync(txt, 'utf8').split('\n')) {
    if (!line) continue;
    species.push(line.trim());
  }
  return species;
}


(async () => {
const gens = new Generations(Dex);
const GEN1 = gens.get(1);

const TYPES = [
  'Normal', 'Fighting', 'Flying', 'Poison', 'Ground', 'Rock', 'Bug', 'Ghost',
  'Fire', 'Water', 'Grass', 'Electric', 'Psychic', 'Ice', 'Dragon'
];

const types = `${PREAMBLE}
const std = @import("std");

const assert = std.debug.assert;

// https://pkmn.cc/pokered/constants/type_constants.asm
pub const Type = enum(u4) {
    ${TYPES.join(',\n    ')},

    comptime {
        assert(@sizeOf(Type) == 1);
    }
};

// https://pkmn.cc/pokered/constants/battle_constants.asm#L52-L57
pub const Efffectiveness = enum(u8) {
    Super = 20,
    Neutral = 10,
    Resisted = 5,
    Immune = 0,

    comptime {
        assert(@sizeOf(Efffectiveness) == 1);
    }
};

const SUPER = Efffectiveness.Super;
const NEUTRAL = Efffectiveness.Neutral;
const RESISTED = Efffectiveness.Resisted;
const IMMUNE = Efffectiveness.Immune;

// https://pkmn.cc/pokered/data/types/type_matchups.asm
pub const TypeChart = [${TYPES.length}][${TYPES.length}]u8{
    // TODO ...
};
`;

fs.writeFileSync(path.join(out, 'types.zig'), types);
zigfmt(path.join(out, 'types.zig'));

const MOVE_IDS = await moveIDs(GEN1);
const MOVES = [];
for (const name of MOVE_IDS) {
  const move = GEN1.moves.get(name);
  MOVES.push(`Move{
    .id = Moves.${name},
    .bp = ${move.basePower},
    .type = Type.${move.type === '???' ? 'Normal' : move.type},
    .accuracy = ${move.accuracy === true ? '100' : move.accuracy},
    .pp = ${move.pp},
}`);
}
const moves = `${PREAMBLE}
const std = @import("std");
const data = @import("../data.zig");

const assert = std.debug.assert;

const Move = data.Move;
const Type = data.Type;

/// https://pkmn.cc/pokered/constants/move_constants.asm
pub const Moves = enum(u8) {
    None,
    ${MOVE_IDS.join(',\n    ')},

    comptime {
        assert(@sizeOf(Moves) == 1);
    }

    pub fn get(id: Moves) *const Move {
        assert(id != .None);
        return &MOVES[@enumToInt(id) - 1];
    }
};

// https://pkmn.cc/pokered/data/moves/moves.asm
const MOVES = [_]Move{ ${MOVES.join(', ')} };
`;

fs.writeFileSync(path.join(out, 'moves.zig'), moves);
zigfmt(path.join(out, 'moves.zig'));

// TODO species

const SPECIES_IDS = await speciesIDs(GEN1);
const SPECIES = [];
for (const name of SPECIES_IDS) {
  const species = GEN1.species.get(name);
  const types = species.types.length === 1
    ? [species.types[0], species.types[0]] : species.types;
  SPECIES.push(`Specie{
    .id = Species.${name},
    .stats = Stats(u8){
        .hp = ${species.baseStats.hp},
        .atk = ${species.baseStats.atk},
        .def = ${species.baseStats.def},
        .spe = ${species.baseStats.spe},
        .spc = ${species.baseStats.spa},
    },
    .types = [_]Type{ Type.${types[0]}, Type.${types[1]} },
}`);
}

const species = `${PREAMBLE}
const std = @import("std");
const data = @import("../data.zig");

const assert = std.debug.assert;

const Specie = data.Specie;
const Stats = data.Stats;
const Type = data.Type;

// https://pkmn.cc/pokered/constants/pokedex_constants.asm
pub const Species = enum(u8) {
    None,
    ${SPECIES_IDS.join(',\n    ')},

    comptime {
        assert(@sizeOf(Species) == 1);
    }

    pub inline fn get(id: Species) *const Specie {
        assert(id != .None);
        return &SPECIES[@enumToInt(id) - 1];
    }
};

// https://pkmn.cc/pokered/data/pokemon/base_stats
const SPECIES = [_]Specie{ ${SPECIES.join(', ')} };
`;

fs.writeFileSync(path.join(out, 'species.zig'), species);
zigfmt(path.join(out, 'species.zig'));
})().catch(err => {
  console.error(err);
  process.exit(1);
});
