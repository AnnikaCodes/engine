#!/usr/bin/env node
'use strict';

const fs = require('fs');
const path = require('path');
const fetch = require('node-fetch');

const {Dex} = require('@pkmn/dex');
const {Generations} = require('@pkmn/data');

const pret = 'https://raw.githubusercontent.com/pret/pokered/master/';
const out = path.resolve(__dirname, '../lib/data');

const toEnum = s => s.replace(/[^A-Za-z0-9]+/g, '');

const UPDATE = process.argv.length > 2;
const PREAMBLE = '//! Code generated by `tools/generate` - manual edits will be overwritten.\n';

async function moveIDs(gen) {
  const txt = path.resolve(__dirname, 'data/moves.txt');

  if (UPDATE) {
    try {
      const moves = [];
      const asm = await (await fetch(`${pret}/data/moves/moves.asm`)).text();
      for (const line of asm.split('\n')) {
        const match = /move (\w+),/.exec(line);
        if (match) {
          const token = match[1] === 'PSYCHIC_M' ? 'PSYCHIC' : match[1];
          moves.push(toEnum(gen.moves.get(token).name));
        }
      }
      fs.writeFileSync(txt, moves.join('\n') + '\n');
      return moves;
    } catch (err) {
      console.error(err);
    }
  }

  const moves = [];
  for (const line of fs.readFileSync(txt, 'utf8').split('\n')) {
    if (!line) continue;
    moves.push(line.trim());
  }
  return moves;
}

async function speciesIDs(gen) {
  const txt = path.resolve(__dirname, 'data/species.txt');

  if (UPDATE) {
    try {
      const species = [];
      const asm = await (await fetch(`${pret}/constants/pokedex_constants.asm`)).text();
      for (const line of asm.split('\n')) {
        const match = /const DEX_(\w+)/.exec(line);
        if (match) species.push(toEnum(gen.species.get(match[1]).name));
      }
      fs.writeFileSync(txt, species.join('\n') + '\n');
      return species;
    } catch (err) {
      console.error(err);
    }
  }

  const species = [];
  for (const line of fs.readFileSync(txt, 'utf8').split('\n')) {
    if (!line) continue;
    species.push(line.trim());
  }
  return species;
}


(async () => {
const gens = new Generations(Dex);
const GEN1 = gens.get(1);

const TYPES = [
  'Normal', 'Fighting', 'Flying', 'Poison', 'Ground', 'Rock', 'Bug', 'Ghost',
  'Fire', 'Water', 'Grass', 'Electric', 'Psychic', 'Ice', 'Dragon'
];
const EFFECTIVENESS = []; {
  for (const t1 of TYPES) {
    const type1 = GEN1.types.get(t1);
    const effectiveness = [];
    for (const t2 of TYPES) {
      const e = type1.effectiveness[t2];
      if (e === 2) {
        effectiveness.push('S');
      } else if (e == 1) {
        effectiveness.push('N');
      } else  if (e === 0.5) {
        effectiveness.push('R');
      } else {
        effectiveness.push('I');
      }
    }
    EFFECTIVENESS.push(`[_]Efffectiveness{ ${effectiveness.join(', ')} }, // ${t1}`);
  }
}
const types = `${PREAMBLE}
const std = @import("std");

const assert = std.debug.assert;

/// Type constants representing all non-glitch types.
///
/// **NOTE**: these do *not* match the in-game values (eg. there is no gap between
/// the Physical and Special types).
///
/// *See:* https://pkmn.cc/pokered/constants/type_constants.asm
///
pub const Type = enum(u4) {
    ${TYPES.join(',\n    ')},

    comptime {
        assert(@sizeOf(Type) == 1);
    }

    pub inline fn effectiveness(t1: Type, t2: Type) Efffectiveness {
        return TYPE_CHART[@enumToInt(t1)][@enumToInt(t2)];
    }
};

/// Type effectiveness factors, scaled by 10 to avoid having to use floating points.
///
/// *See:* https://pkmn.cc/pokered/constants/battle_constants.asm#L52-L57
///
pub const Efffectiveness = enum(u8) {
    Super = 20,
    Neutral = 10,
    Resisted = 5,
    Immune = 0,

    comptime {
        assert(@sizeOf(Efffectiveness) == 1);
    }
};

const S = Efffectiveness.Super;
const N = Efffectiveness.Neutral;
const R = Efffectiveness.Resisted;
const I = Efffectiveness.Immune;

/// Type chart, organizated in terms of damage-dealt like on the cartridge. However,
/// unlike in-game we store the entire table as a multidimensional array for faster
/// queries (the cartridge's approach of only listing non-neutral matchups saves memory
/// but requires linear scanning for lookups).
///
/// **NOTE**: Pokémon Showdown stores its type chart in the reverse order (ie. damage-dealt).
///
/// *See:* ttps://pkmn.cc/pokered/data/types/type_matchups.asm
///
const TYPE_CHART = [${TYPES.length}][${TYPES.length}]Efffectiveness{
    ${EFFECTIVENESS.join('\n    ')}
};
`;

fs.writeFileSync(path.join(out, 'types.zig'), types);

const MOVE_IDS = await moveIDs(GEN1);
const MOVES = [];
for (const name of MOVE_IDS) {
  const move = GEN1.moves.get(name);
  MOVES.push(`Move{
    .id = .${name},
    .bp = ${move.basePower},
    .type = .${move.type === '???' ? 'Normal' : move.type},
    .accuracy = ${move.accuracy === true ? '100' : move.accuracy},
    .pp = ${move.pp},
}`);
}
const moves = `${PREAMBLE}
const std = @import("std");
const data = @import("../data.zig");

const assert = std.debug.assert;

const Move = data.Move;
const Type = data.Type;

/// Move constants representing all legal moves, plus the sentinel \`None\`.
/// The sentinal value is guaranteed to be bit-equivalent to \`0\` and can be
/// used to represent a null-pointer equivalent without using the additional
/// byte that \`?Moves\` would entail.
///
/// *See:* https://pkmn.cc/pokered/constants/move_constants.asm
///
pub const Moves = enum(u8) {
    None,
    ${MOVE_IDS.join(',\n    ')},

    comptime {
        assert(@sizeOf(Moves) == 1);
    }

    pub fn get(id: Moves) *const Move {
        assert(id != .None);
        return &MOVES[@enumToInt(id) - 1];
    }
};

// TODO: add effect handler data
/// Basic raw move data - names and descriptions are handled elswhere.
///
/// **NOTE:** this data differs from Pokémon Showdown:
///
///   - Bide has \`Normal\`-type instead of \`???\`-type
///   - moves which always hit have \`accuracy\` of \`100\` instead of \`true\`
///   - numerous fields (volatiles, multihit, etc) are handled differently and
///     thus do not appear in the data definitions below
///
/// *See:* https://pkmn.cc/pokered/data/moves/moves.asm
///
const MOVES = [_]Move{ ${MOVES.join(', ')} };
`;

fs.writeFileSync(path.join(out, 'moves.zig'), moves);

const SPECIES_IDS = await speciesIDs(GEN1);
const SPECIES = [];
for (const name of SPECIES_IDS) {
  const species = GEN1.species.get(name);
  const types = species.types.length === 1
    ? [species.types[0], species.types[0]] : species.types;
  SPECIES.push(`Specie{
    .id = .${name},
    .stats = Stats(u8){
        .hp = ${species.baseStats.hp},
        .atk = ${species.baseStats.atk},
        .def = ${species.baseStats.def},
        .spe = ${species.baseStats.spe},
        .spc = ${species.baseStats.spa},
    },
    .types = [_]Type{ .${types[0]}, .${types[1]} },
}`);
}

const species = `${PREAMBLE}
const std = @import("std");
const data = @import("../data.zig");

const assert = std.debug.assert;

const Specie = data.Specie;
const Stats = data.Stats;
const Type = data.Type;

/// Species constants representing all legal moves, plus the sentinel \`None\`.
/// The sentinal value is guaranteed to be bit-equivalent to \`0\` and can be
/// used to represent a null-pointer equivalent without using the additional
/// byte that \`?Species\` would entail.
///
/// *See:* https://pkmn.cc/pokered/constants/pokedex_constants.asm
///
pub const Species = enum(u8) {
    None,
    ${SPECIES_IDS.join(',\n    ')},

    comptime {
        assert(@sizeOf(Species) == 1);
    }

    pub inline fn get(id: Species) *const Specie {
        assert(id != .None);
        return &SPECIES[@enumToInt(id) - 1];
    }
};

/// Basic raw species data - names and descriptions are handled elswhere.
///
/// **NOTE:** just like in-game, each Pokémon has two types (Pokémon Showdown
/// elides the second type if its redundant, but dealing with variable length
/// and alignment arrays is more trouble and more often than not amounts to the
/// same space requirements).
///
/// *See:* https://pkmn.cc/pokered/data/pokemon/base_stats
///
const SPECIES = [_]Specie{ ${SPECIES.join(', ')} };
`;

fs.writeFileSync(path.join(out, 'species.zig'), species);
})().catch(err => {
  console.error(err);
  process.exit(1);
});
